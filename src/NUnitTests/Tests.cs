using Avalonia.Controls;
using Avalonia.Platform;

[TestFixture]
public class Tests
{
    // static Dictionary<Type, List<string>> ignoredMembers = new()
    // {
    // };

    static List<Type> ignoredTypes = new()
    {
        typeof(IWindowBaseImpl)
    };

    [Test]
    public void Types()
    {
        var solutionDirectory = AttributeReader.GetSolutionDirectory();
        var convertersPath = Path.Combine(solutionDirectory, @"Verify.Avalonia\Converters\");
        foreach (var file in Directory.EnumerateFiles(convertersPath))
        {
            File.Delete(file);
        }

        var visual = typeof(Visual);
        var types = typeof(Window).Assembly.GetTypes()
            .Concat(
                typeof(InputElement).Assembly.GetTypes())
            .Where(_ => _.IsAssignableTo(visual) && _.IsPublic)
            .OrderByDescending(GetDepth)
            .ToList();
        foreach (var type in types)
        {
            WriteType(type, convertersPath);
        }

        WriteConvertersFile(solutionDirectory, types);
    }

    static void WriteConvertersFile(string solutionDirectory, List<Type> types)
    {
        var path = Path.Combine(solutionDirectory, @"Verify.Avalonia\Converters\VerifyAvalonia_Converters.cs");

        using var writer = File.CreateText(path);
        writer.WriteLine(
            """
            namespace VerifyTests;

            public static partial class VerifyAvalonia
            {
                static void AddConverters() =>
                    VerifierSettings.AddExtraSettings(
                        _ =>
                        {
            """);
        foreach (var type in types)
        {
            writer.WriteLine(
                $"                _.Converters.Add(new {type.Name}Converter());");
        }

        writer.WriteLine(
            """
                         });
            }
            """);
    }

    static int GetDepth(Type type)
    {
        var level = 0;
        while (type != typeof(object))
        {
            level++;
            type = type.BaseType!;
        }

        return level;
    }

    static void WriteType(Type type, string convertersPath)
    {
        var builder = new StringBuilder();
        builder.AppendLine(
            $$"""
              // <auto-generated />
              class {{type.Name}}Converter :
                  WriteOnlyJsonConverter<{{type.Name}}>
              {
                  public override void Write(VerifyJsonWriter writer, {{type.Name}} value)
                  {
                      writer.WriteStartObject();
                      VerifyAvalonia.WriteGeneratedMembers(writer, value);
                      WriteMembers(writer, value);
              """);

        if (type != typeof(Visual))
        {
            builder.AppendLine($"        {type.BaseType!.Name}Converter.WriteMembers(writer, value);");
        }

        builder.AppendLine(
            """
                    writer.WriteEndObject();
                }
            """);

        builder.AppendLine(
            $$"""
              
                  public static void WriteMembers(VerifyJsonWriter writer, {{type.Name}} value)
                  {
              """);
        foreach (var property in type.GetProperties(BindingFlags.Instance | BindingFlags.Public))
        {
            AppendProperty(type, property, builder);
        }

        builder.AppendLine("    }");
        builder.AppendLine("}");
        File.WriteAllText(Path.Combine(convertersPath, $"{type.Name}Converter.cs"), builder.ToString());
    }

    static void AppendProperty(Type type, PropertyInfo property, StringBuilder builder)
    {
        if (property.DeclaringType != type)
        {
            return;
        }

        if (property.GetCustomAttribute<ObsoleteAttribute>() != null)
        {
            return;
        }

        if (ignoredTypes.Any(_ => _.IsAssignableFrom(property.PropertyType)))
        {
            return;
        }
        //
        // if (typeof(Delegate).IsAssignableFrom(property.PropertyType))
        // {
        //     continue;
        // }

        var name = property.Name;
        var attachedProperty = type.GetField($"{name}Property");
        if (attachedProperty == null)
        {
            builder.AppendLine(
                $"""
                          writer.WriteMember(value, value.{name}, "{name}");
                 """);
            return;
        }

        var genericType = attachedProperty.FieldType.GetGenericTypeDefinition();
        if (genericType == typeof(StyledProperty<>))
        {
            builder.AppendLine(
                $$"""
                           if ({{type.Name}}.{{name}}Property.GetDefaultValue(typeof({{type.Name}})) == value.{{name}})
                           {
                               writer.WriteMember(value, value.{{name}}, "{{name}}");
                           }
                  """);
            return;
        }
        if (genericType == typeof(DirectProperty<,>))
        {
            builder.AppendLine(
                $$"""
                           if ({{type.Name}}.{{name}}Property.GetUnsetValue(typeof({{type.Name}})) == value.{{name}})
                           {
                               writer.WriteMember(value, value.{{name}}, "{{name}}");
                           }
                  """);
        }
    }
}