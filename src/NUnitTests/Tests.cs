using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Platform;

[TestFixture]
public class Tests
{
    static List<Type> ignoredTypes = new()
    {
        typeof(IWindowBaseImpl),
        typeof(IControlTemplate)
    };

    [Test]
    public void Types()
    {
        var solutionDirectory = AttributeReader.GetSolutionDirectory();
        var convertersPath = Path.Combine(solutionDirectory, @"Verify.Avalonia\GeneratedConverters\");
        foreach (var file in Directory.EnumerateFiles(convertersPath))
        {
            File.Delete(file);
        }

        var visual = typeof(Visual);
        var types =
            //Avalonia.Controls
            typeof(Window).Assembly.GetTypes()
                .Concat(
                    //Avalonia.Base
                    typeof(InputElement).Assembly.GetTypes())
                .Concat(
                    //Avalonia.Controls.ColorPicker
                    typeof(ColorPicker).Assembly.GetTypes())
                .Concat(
                    //Avalonia.Controls.DataGrid
                    typeof(DataGrid).Assembly.GetTypes())

                .Where(_ => _.IsAssignableTo(visual) && _.IsPublic)
                .OrderByDescending(GetDepth)
                .ToList();
        foreach (var type in types)
        {
            WriteType(type, convertersPath);
        }

        WriteConvertersFile(solutionDirectory, types);
    }

    static void WriteConvertersFile(string solutionDirectory, List<Type> types)
    {
        var path = Path.Combine(solutionDirectory, @"Verify.Avalonia\VerifyAvalonia_Converters.cs");

        File.Delete(path);
        using var writer = File.CreateText(path);
        writer.WriteLine(
            """
            namespace VerifyTests;

            public static partial class VerifyAvalonia
            {
                static void AddConverters() =>
                    VerifierSettings.AddExtraSettings(
                        _ =>
                        {
            """);
        foreach (var type in types)
        {
            writer.WriteLine(
                $"                _.Converters.Add(new {type.Name}Converter());");
        }

        writer.WriteLine(
            """
                         });
            }
            """);
    }

    static int GetDepth(Type type)
    {
        var level = 0;
        while (type != typeof(object))
        {
            level++;
            type = type.BaseType!;
        }

        return level;
    }

    static void WriteType(Type type, string convertersPath)
    {
        var builder = new StringBuilder();
        builder.AppendLine(
            $$"""
              // <auto-generated />
              #nullable enable
              class {{type.Name}}Converter :
                  WriteOnlyJsonConverter<{{type.Name}}>
              {
                  public override void Write(VerifyJsonWriter writer, {{type.Name}} value)
                  {
                      writer.WriteStartObject();
                      VerifyAvalonia.WriteGeneratedMembers(writer, value);
                      WriteMembers(writer, value);
              """);

        if (type != typeof(Visual))
        {
            builder.AppendLine($"        {type.BaseType!.Name}Converter.WriteMembers(writer, value);");
        }

        builder.AppendLine(
            """
                    writer.WriteEndObject();
                }
            """);

        WriteMembers(type, builder);
        MemberHasValue(type, builder);
        builder.AppendLine("}");
        File.WriteAllText(Path.Combine(convertersPath, $"{type.Name}Converter.cs"), builder.ToString());
    }

    static void WriteMembers(Type type, StringBuilder builder)
    {
        builder.AppendLine(
            $$"""
              
                  public static void WriteMembers(VerifyJsonWriter writer, {{type.Name}} value)
                  {
              """);
        foreach (var property in GetPropertiesToProcess(type))
        {
            AppendProperty(type, property, builder);
        }

        builder.AppendLine("    }");
    }

    static IEnumerable<PropertyInfo> GetPropertiesToProcess(Type type) =>
        type.GetProperties(BindingFlags.Instance | BindingFlags.Public)
            .Where(_ => _.DeclaringType == type &&
                        _.GetCustomAttribute<ObsoleteAttribute>() == null &&
                        !ignoredTypes.Any(ignored => ignored.IsAssignableFrom(_.PropertyType)));

    static void MemberHasValue(Type type, StringBuilder builder)
    {
        builder.AppendLine(
            $$"""
              
                  public static bool MemberHasValue({{type.Name}} target, string member, object? value)
                  {
              """);
        foreach (var property in GetPropertiesToProcess(type))
        {
            var name = property.Name;
            builder.AppendLine(
                $$"""
                          if (member == "{{name}}")
                          {
                              return object.Equals(target.{{name}}, value);
                          }
                  """);
        }

        if (type != typeof(Visual))
        {
            builder.AppendLine($"        {type.BaseType!.Name}Converter.MemberHasValue(target, member, value);");
        }

        builder.AppendLine(
            """
                    throw new($"Member not found: {member}");
                }
            """);
    }

    static void AppendProperty(Type type, PropertyInfo property, StringBuilder builder)
    {
        var name = property.Name;
        var attachedProperty = type.GetField($"{name}Property");
        if (attachedProperty == null)
        {
            builder.AppendLine(
                $"         writer.WriteMember(value, value.{name}, \"{name}\");");
            return;
        }

        var genericType = attachedProperty.FieldType.GetGenericTypeDefinition();

        var getDefault = GetDefaultMethod(genericType, attachedProperty);

        builder.AppendLine(
            $$"""
                      if (!object.Equals({{type.Name}}.{{name}}Property.{{getDefault}}(typeof({{type.Name}})), value.{{name}}))
                      {
                          writer.WriteMember(value, value.{{name}}, "{{name}}");
                      }
              """);
    }

    static string GetDefaultMethod(Type genericType, FieldInfo attachedProperty)
    {
        if (genericType == typeof(StyledProperty<>) ||
            genericType == typeof(AttachedProperty<>))
        {
            return "GetDefaultValue";
        }

        if (genericType == typeof(DirectProperty<,>))
        {
            return "GetUnsetValue";
        }

        throw new(attachedProperty.FieldType.FullName);
    }
}