using Avalonia.Controls;
using Avalonia.Platform;

[TestFixture]
public class Tests
{
    // static Dictionary<Type, List<string>> ignoredMembers = new()
    // {
    // };

    static List<Type> ignoredTypes = new()
    {
        typeof(IWindowBaseImpl)
    };

    [Test]
    public void Types()
    {
        var solutionDirectory = AttributeReader.GetSolutionDirectory();
        var convertersPath = Path.Combine(solutionDirectory, @"Verify.Avalonia\Converters\");
        foreach (var file in Directory.EnumerateFiles(convertersPath))
        {
            File.Delete(file);
        }

        var visual = typeof(Visual);
        var types = typeof(Window).Assembly.GetTypes()
            .Concat(
                typeof(InputElement).Assembly.GetTypes())
            .Where(_ => _.IsAssignableTo(visual) && _.IsPublic)
            .ToList();
        types.Add(visual);
        foreach (var type in types)
        {
            WriteType(type, convertersPath);
        }

        var convertersFilePath = Path.Combine(solutionDirectory, @"Verify.Avalonia\Converters\VerifyAvalonia_Converters.cs");

        using var converterFile = File.CreateText(convertersFilePath);
        converterFile.WriteLine(
            """
            namespace VerifyTests;

            public static partial class VerifyAvalonia
            {
                static void AddConverters() =>
                    VerifierSettings.AddExtraSettings(
                        _ =>
                        {
            """);
        foreach (var type in types)
        {
            converterFile.WriteLine(
                $"                _.Converters.Add(new {type.Name}Converter());");
        }
        converterFile.WriteLine(
            """
                         });
            }
            """);
    }

    static void WriteType(Type type, string convertersPath)
    {
        var builder = new StringBuilder();
        builder.AppendLine(
            $$"""
              // <auto-generated />
              class {{type.Name}}Converter :
                  WriteOnlyJsonConverter<{{type.Name}}>
              {
                  public override void Write(VerifyJsonWriter writer, {{type.Name}} value)
                  {
                      writer.WriteStartObject();
                      WriteMembers(writer, value);
              """);
        if (type != typeof(Visual))
        {
            builder.AppendLine(
                $"        {type.BaseType!.Name}Converter.WriteMembers(writer, value);");
        }

        builder.AppendLine(
            """
                    writer.WriteEndObject();
                }
            """);

        builder.AppendLine(
            $$"""
              
                  public static void WriteMembers(VerifyJsonWriter writer, {{type.Name}} value)
                  {
              """);
        foreach (var property in type.GetProperties(BindingFlags.Instance | BindingFlags.Public))
        {
            if (property.DeclaringType != type)
            {
                continue;
            }

            if (property.GetCustomAttribute<ObsoleteAttribute>() != null)
            {
                continue;
            }

            if (ignoredTypes.Any(ignoredType => ignoredType.IsAssignableFrom(property.PropertyType)))
            {
                continue;
            }
            //
            // if (typeof(Delegate).IsAssignableFrom(property.PropertyType))
            // {
            //     continue;
            // }

            builder.AppendLine(
                $"""
                          writer.WriteMember(value, value.{property.Name}, "{property.Name}");
                 """);
        }

        builder.AppendLine("    }");
        builder.AppendLine("}");
        File.WriteAllText(Path.Combine(convertersPath, $"{type.Name}Converter.cs"), builder.ToString());
    }
}