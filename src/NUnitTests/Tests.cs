using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Platform;

[TestFixture]
public class Tests
{
    static List<Type> ignoredTypes = new()
    {
        typeof(IWindowBaseImpl),
        typeof(IControlTemplate)
    };

    [Test]
    public void Types()
    {
        var solutionDirectory = AttributeReader.GetSolutionDirectory();
        var convertersPath = Path.Combine(solutionDirectory, @"Verify.Avalonia\GeneratedConverters\");
        foreach (var file in Directory.EnumerateFiles(convertersPath))
        {
            File.Delete(file);
        }

        var visual = typeof(Visual);
        var types =
            //Avalonia.Controls
            typeof(Window).Assembly.GetTypes()
                .Concat(
                    //Avalonia.Base
                    typeof(InputElement).Assembly.GetTypes())
                .Concat(
                    //Avalonia.Controls.ColorPicker
                    typeof(ColorPicker).Assembly.GetTypes())
                .Concat(
                    //Avalonia.Controls.DataGrid
                    typeof(DataGrid).Assembly.GetTypes())

                .Where(_ => _.IsAssignableTo(visual) && _.IsPublic)
                .OrderByDescending(GetDepth)
                .ToList();
        foreach (var type in types)
        {
            WriteType(type, convertersPath);
        }

        WriteConvertersFile(solutionDirectory, types);
    }

    static void WriteConvertersFile(string solutionDirectory, List<Type> types)
    {
        var path = Path.Combine(solutionDirectory, @"Verify.Avalonia\VerifyAvalonia_Converters.cs");

        File.Delete(path);
        using var writer = File.CreateText(path);
        writer.WriteLine(
            """
            namespace VerifyTests;

            public static partial class VerifyAvalonia
            {
                static void AddConverters() =>
                    VerifierSettings.AddExtraSettings(
                        _ =>
                        {
            """);
        foreach (var type in types)
        {
            writer.WriteLine(
                $"                _.Converters.Add(new {type.Name}Converter());");
        }

        writer.WriteLine(
            """
                         });
            }
            """);
    }

    static int GetDepth(Type type)
    {
        var level = 0;
        while (type != typeof(object))
        {
            level++;
            type = type.BaseType!;
        }

        return level;
    }

    static void WriteType(Type type, string convertersPath)
    {
        var builder = new StringBuilder();
        builder.AppendLine(
            $$"""
              // <auto-generated />
              class {{type.Name}}Converter :
                  WriteOnlyJsonConverter<{{type.Name}}>
              {
                  public override void Write(VerifyJsonWriter writer, {{type.Name}} value)
                  {
                      writer.WriteStartObject();
                      VerifyAvalonia.WriteGeneratedMembers(writer, value);
                      WriteMembers(writer, value);
              """);

        if (type != typeof(Visual))
        {
            builder.AppendLine($"        {type.BaseType!.Name}Converter.WriteMembers(writer, value);");
        }

        builder.AppendLine(
            """
                    writer.WriteEndObject();
                }
            """);

        builder.AppendLine(
            $$"""
              
                  public static void WriteMembers(VerifyJsonWriter writer, {{type.Name}} value)
                  {
              """);
        foreach (var property in type.GetProperties(BindingFlags.Instance | BindingFlags.Public))
        {
            AppendProperty(type, property, builder);
        }

        builder.AppendLine("    }");
        builder.AppendLine("}");
        File.WriteAllText(Path.Combine(convertersPath, $"{type.Name}Converter.cs"), builder.ToString());
    }

    static void AppendProperty(Type type, PropertyInfo property, StringBuilder builder)
    {
        if (property.DeclaringType != type)
        {
            return;
        }

        if (property.GetCustomAttribute<ObsoleteAttribute>() != null)
        {
            return;
        }

        var propertyType = property.PropertyType;
        if (ignoredTypes.Any(_ => _.IsAssignableFrom(propertyType)))
        {
            return;
        }
        //
        // if (typeof(Delegate).IsAssignableFrom(property.PropertyType))
        // {
        //     continue;
        // }

        var name = property.Name;
        var attachedProperty = type.GetField($"{name}Property");
        if (attachedProperty == null)
        {
            builder.AppendLine(
                $"""
                          writer.WriteMember(value, value.{name}, "{name}");
                 """);
            return;
        }

        var propertyDefinition = $"{type.Name}.{name}Property";

        var genericType = attachedProperty.FieldType.GetGenericTypeDefinition();

        void WriteWrite() =>
            builder.AppendLine(
                $$"""
                          {
                              writer.WriteMember(value, value.{{name}}, "{{name}}");
                          }
                  """);

        if (genericType == typeof(StyledProperty<>) ||
            genericType == typeof(AttachedProperty<>))
        {
            if (propertyType.IsValueType)
            {
                builder.AppendLine($"        if (!{propertyDefinition}.GetDefaultValue(typeof({type.Name})).Equals(value.{name}))");
            }
            else
            {
                builder.AppendLine($"        if ({propertyDefinition}.GetDefaultValue(typeof({type.Name})) != value.{name})");
            }

            WriteWrite();
            return;
        }

        if (genericType == typeof(DirectProperty<,>))
        {
            if (propertyType.IsValueType)
            {
                builder.AppendLine($"        if (!{propertyDefinition}.GetUnsetValue(typeof({type.Name})).Equals(value.{name}))");
            }
            else
            {
                builder.AppendLine($"        if ({propertyDefinition}.GetUnsetValue(typeof({type.Name})) != value.{name})");
            }

            WriteWrite();
            return;
        }

        throw new(attachedProperty.FieldType.FullName);
    }
}